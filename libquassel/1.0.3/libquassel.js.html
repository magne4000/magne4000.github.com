<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>libquassel.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-buffer.IRCBuffer.html">IRCBuffer</a><ul class='methods'><li data-type='method'><a href="module-buffer.IRCBuffer.html#addMessage">addMessage</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#addUser">addUser</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#addUserMode">addUserMode</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#devour">devour</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#getBufferInfo">getBufferInfo</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#getFirstMessage">getFirstMessage</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#getLastMessage">getLastMessage</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#hasMode">hasMode</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#hasUser">hasUser</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#isChannel">isChannel</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#isHidden">isHidden</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#isLast">isLast</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#isOp">isOp</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#isStatusBuffer">isStatusBuffer</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#isVoiced">isVoiced</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#removeUser">removeUser</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#removeUserMode">removeUserMode</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#setActive">setActive</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#setName">setName</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#setOrder">setOrder</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#setPermanentlyRemoved">setPermanentlyRemoved</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#setTemporarilyRemoved">setTemporarilyRemoved</a></li><li data-type='method'><a href="module-buffer.IRCBuffer.html#updateUserMaps">updateUserMaps</a></li></ul></li><li><a href="module-buffer.IRCBufferCollection.html">IRCBufferCollection</a><ul class='methods'><li data-type='method'><a href="module-buffer.IRCBufferCollection.html#_computeFilteredBuffers">_computeFilteredBuffers</a></li><li data-type='method'><a href="module-buffer.IRCBufferCollection.html#_isBufferFiltered">_isBufferFiltered</a></li><li data-type='method'><a href="module-buffer.IRCBufferCollection.html#addBuffer">addBuffer</a></li><li data-type='method'><a href="module-buffer.IRCBufferCollection.html#getBuffer">getBuffer</a></li><li data-type='method'><a href="module-buffer.IRCBufferCollection.html#hasBuffer">hasBuffer</a></li><li data-type='method'><a href="module-buffer.IRCBufferCollection.html#moveBuffer">moveBuffer</a></li><li data-type='method'><a href="module-buffer.IRCBufferCollection.html#removeBuffer">removeBuffer</a></li></ul></li><li><a href="module-glouton.Glouton.html">Glouton</a><ul class='methods'><li data-type='method'><a href="module-glouton.Glouton.html#.extend">extend</a></li><li data-type='method'><a href="module-glouton.Glouton.html#devour">devour</a></li></ul></li><li><a href="module-identity.html">identity</a><ul class='methods'><li data-type='method'><a href="module-identity.html#devour">devour</a></li><li data-type='method'><a href="module-identity.html#setAutoAwayEnabled">setAutoAwayEnabled</a></li><li data-type='method'><a href="module-identity.html#setAutoAwayReason">setAutoAwayReason</a></li><li data-type='method'><a href="module-identity.html#setAutoAwayReasonEnabled">setAutoAwayReasonEnabled</a></li><li data-type='method'><a href="module-identity.html#setAutoAwayTime">setAutoAwayTime</a></li><li data-type='method'><a href="module-identity.html#setAwayNick">setAwayNick</a></li><li data-type='method'><a href="module-identity.html#setAwayNickEnabled">setAwayNickEnabled</a></li><li data-type='method'><a href="module-identity.html#setAwayReason">setAwayReason</a></li><li data-type='method'><a href="module-identity.html#setAwayReasonEnabled">setAwayReasonEnabled</a></li><li data-type='method'><a href="module-identity.html#setDetachAwayEnabled">setDetachAwayEnabled</a></li><li data-type='method'><a href="module-identity.html#setDetachAwayReason">setDetachAwayReason</a></li><li data-type='method'><a href="module-identity.html#setDetachAwayReasonEnabled">setDetachAwayReasonEnabled</a></li><li data-type='method'><a href="module-identity.html#setId">setId</a></li><li data-type='method'><a href="module-identity.html#setIdent">setIdent</a></li><li data-type='method'><a href="module-identity.html#setIdentityName">setIdentityName</a></li><li data-type='method'><a href="module-identity.html#setKickReason">setKickReason</a></li><li data-type='method'><a href="module-identity.html#setNicks">setNicks</a></li><li data-type='method'><a href="module-identity.html#setPartReason">setPartReason</a></li><li data-type='method'><a href="module-identity.html#setQuitReason">setQuitReason</a></li><li data-type='method'><a href="module-identity.html#setRealName">setRealName</a></li><li data-type='method'><a href="module-identity.html#update">update</a></li></ul></li><li><a href="module-ignore.IgnoreItem.html">IgnoreItem</a><ul class='methods'><li data-type='method'><a href="module-ignore.IgnoreItem.html#matchIgnore">matchIgnore</a></li><li data-type='method'><a href="module-ignore.IgnoreItem.html#matchScope">matchScope</a></li><li data-type='method'><a href="module-ignore.IgnoreItem.html#revived">revived</a></li></ul></li><li><a href="module-ignore.IgnoreList.html">IgnoreList</a><ul class='methods'><li data-type='method'><a href="module-ignore.IgnoreList.html#export">export</a></li><li data-type='method'><a href="module-ignore.IgnoreList.html#import">import</a></li><li data-type='method'><a href="module-ignore.IgnoreList.html#matches">matches</a></li></ul></li><li><a href="module-libquassel-Quassel.html">Quassel</a><ul class='methods'><li data-type='method'><a href="module-libquassel-Quassel.html#connect">connect</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#createBuffer">createBuffer</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#createIdentity">createIdentity</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#createNetwork">createNetwork</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#disconnect">disconnect</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#dispatch">dispatch</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#getMaxBufferId">getMaxBufferId</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#getNetworks">getNetworks</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#getNetworksMap">getNetworksMap</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#handleInitDataNetwork">handleInitDataNetwork</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#handleMsgType">handleMsgType</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#handleStruct">handleStruct</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#heartBeat">heartBeat</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#init">init</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#login">login</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#removeIdentity">removeIdentity</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#removeNetwork">removeNetwork</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestBacklog">requestBacklog</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestBacklogs">requestBacklogs</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestConnectNetwork">requestConnectNetwork</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestDisconnectNetwork">requestDisconnectNetwork</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestHideBufferPermanently">requestHideBufferPermanently</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestHideBufferTemporarily">requestHideBufferTemporarily</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestMarkBufferAsRead">requestMarkBufferAsRead</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestMergeBuffersPermanently">requestMergeBuffersPermanently</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestRemoveBuffer">requestRemoveBuffer</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestSetLastMsgRead">requestSetLastMsgRead</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestSetMarkerLine">requestSetMarkerLine</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestSetNetworkInfo">requestSetNetworkInfo</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestUnhideBuffer">requestUnhideBuffer</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestUpdateIdentity">requestUpdateIdentity</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#requestUpdateIgnoreListManager">requestUpdateIgnoreListManager</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#sendClientInfo">sendClientInfo</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#sendInitRequest">sendInitRequest</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#sendMessage">sendMessage</a></li><li data-type='method'><a href="module-libquassel-Quassel.html#setupCore">setupCore</a></li></ul></li><li><a href="module-message.IRCMessage.html">IRCMessage</a><ul class='methods'><li data-type='method'><a href="module-message.IRCMessage.html#_updateFlags">_updateFlags</a></li><li data-type='method'><a href="module-message.IRCMessage.html#getHostmask">getHostmask</a></li><li data-type='method'><a href="module-message.IRCMessage.html#getNick">getNick</a></li><li data-type='method'><a href="module-message.IRCMessage.html#isHighlighted">isHighlighted</a></li><li data-type='method'><a href="module-message.IRCMessage.html#isSelf">isSelf</a></li></ul></li><li><a href="module-network.Network.html">Network</a><ul class='methods'><li data-type='method'><a href="module-network.Network.html#.toQ">toQ</a></li><li data-type='method'><a href="module-network.Network.html#addUser">addUser</a></li><li data-type='method'><a href="module-network.Network.html#devour">devour</a></li><li data-type='method'><a href="module-network.Network.html#getBuffer">getBuffer</a></li><li data-type='method'><a href="module-network.Network.html#getBufferCollection">getBufferCollection</a></li><li data-type='method'><a href="module-network.Network.html#getBufferMap">getBufferMap</a></li><li data-type='method'><a href="module-network.Network.html#getStatusBuffer">getStatusBuffer</a></li><li data-type='method'><a href="module-network.Network.html#getUserByNick">getUserByNick</a></li><li data-type='method'><a href="module-network.Network.html#hasNick">hasNick</a></li><li data-type='method'><a href="module-network.Network.html#removeUser">removeUser</a></li><li data-type='method'><a href="module-network.Network.html#renameUser">renameUser</a></li><li data-type='method'><a href="module-network.Network.html#setConnected">setConnected</a></li><li data-type='method'><a href="module-network.Network.html#setIrcUsersAndChannels">setIrcUsersAndChannels</a></li><li data-type='method'><a href="module-network.Network.html#setLatency">setLatency</a></li><li data-type='method'><a href="module-network.Network.html#setMyNick">setMyNick</a></li><li data-type='method'><a href="module-network.Network.html#setName">setName</a></li><li data-type='method'><a href="module-network.Network.html#setServer">setServer</a></li><li data-type='method'><a href="module-network.Network.html#setStatusBuffer">setStatusBuffer</a></li><li data-type='method'><a href="module-network.Network.html#setUserList">setUserList</a></li><li data-type='method'><a href="module-network.Network.html#updateTopic">updateTopic</a></li></ul></li><li><a href="module-network.NetworkCollection.html">NetworkCollection</a><ul class='methods'><li data-type='method'><a href="module-network.NetworkCollection.html#add">add</a></li><li data-type='method'><a href="module-network.NetworkCollection.html#delete">delete</a></li><li data-type='method'><a href="module-network.NetworkCollection.html#findBuffer">findBuffer</a></li><li data-type='method'><a href="module-network.NetworkCollection.html#get">get</a></li><li data-type='method'><a href="module-network.NetworkCollection.html#removeBuffer">removeBuffer</a></li><li data-type='method'><a href="module-network.NetworkCollection.html#set">set</a></li><li data-type='method'><a href="module-network.NetworkCollection.html#values">values</a></li></ul></li><li><a href="module-user.html">user</a><ul class='methods'><li data-type='method'><a href="module-user.html#devour">devour</a></li><li data-type='method'><a href="module-user.html#setAway">setAway</a></li><li data-type='method'><a href="module-user.html#setEncrypted">setEncrypted</a></li><li data-type='method'><a href="module-user.html#setLastAwayMessage">setLastAwayMessage</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-buffer.html">buffer</a></li><li><a href="module-glouton.html">glouton</a></li><li><a href="module-identity.html">identity</a><ul class='methods'><li data-type='method'><a href="module-identity.html#devour">devour</a></li><li data-type='method'><a href="module-identity.html#setAutoAwayEnabled">setAutoAwayEnabled</a></li><li data-type='method'><a href="module-identity.html#setAutoAwayReason">setAutoAwayReason</a></li><li data-type='method'><a href="module-identity.html#setAutoAwayReasonEnabled">setAutoAwayReasonEnabled</a></li><li data-type='method'><a href="module-identity.html#setAutoAwayTime">setAutoAwayTime</a></li><li data-type='method'><a href="module-identity.html#setAwayNick">setAwayNick</a></li><li data-type='method'><a href="module-identity.html#setAwayNickEnabled">setAwayNickEnabled</a></li><li data-type='method'><a href="module-identity.html#setAwayReason">setAwayReason</a></li><li data-type='method'><a href="module-identity.html#setAwayReasonEnabled">setAwayReasonEnabled</a></li><li data-type='method'><a href="module-identity.html#setDetachAwayEnabled">setDetachAwayEnabled</a></li><li data-type='method'><a href="module-identity.html#setDetachAwayReason">setDetachAwayReason</a></li><li data-type='method'><a href="module-identity.html#setDetachAwayReasonEnabled">setDetachAwayReasonEnabled</a></li><li data-type='method'><a href="module-identity.html#setId">setId</a></li><li data-type='method'><a href="module-identity.html#setIdent">setIdent</a></li><li data-type='method'><a href="module-identity.html#setIdentityName">setIdentityName</a></li><li data-type='method'><a href="module-identity.html#setKickReason">setKickReason</a></li><li data-type='method'><a href="module-identity.html#setNicks">setNicks</a></li><li data-type='method'><a href="module-identity.html#setPartReason">setPartReason</a></li><li data-type='method'><a href="module-identity.html#setQuitReason">setQuitReason</a></li><li data-type='method'><a href="module-identity.html#setRealName">setRealName</a></li><li data-type='method'><a href="module-identity.html#update">update</a></li></ul></li><li><a href="module-ignore.html">ignore</a></li><li><a href="module-libquassel.html">libquassel</a></li><li><a href="module-message.html">message</a></li><li><a href="module-network.html">network</a></li><li><a href="module-requesttype.html">requesttype</a></li><li><a href="module-user.html">user</a><ul class='methods'><li data-type='method'><a href="module-user.html#devour">devour</a></li><li data-type='method'><a href="module-user.html#setAway">setAway</a></li><li data-type='method'><a href="module-user.html#setEncrypted">setEncrypted</a></li><li data-type='method'><a href="module-user.html#setLastAwayMessage">setLastAwayMessage</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.activate%2522">event:"buffer.activate"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.backlog%2522">event:"buffer.backlog"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.deactivate%2522">event:"buffer.deactivate"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.hidden%2522">event:"buffer.hidden"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.lastseen%2522">event:"buffer.lastseen"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.markerline%2522">event:"buffer.markerline"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.merge%2522">event:"buffer.merge"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.message%2522">event:"buffer.message"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.order%2522">event:"buffer.order"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.read%2522">event:"buffer.read"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.remove%2522">event:"buffer.remove"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.rename%2522">event:"buffer.rename"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522buffer.unhide%2522">event:"buffer.unhide"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522channel.addusermode%2522">event:"channel.addusermode"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522channel.join%2522">event:"channel.join"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522channel.removeusermode%2522">event:"channel.removeusermode"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522channel.topic%2522">event:"channel.topic"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522coreinfo%2522">event:"coreinfo"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522coreinfoinit%2522">event:"coreinfoinit"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522error%2522">event:"error"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522identities.init%2522">event:"identities.init"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522identity.new%2522">event:"identity.new"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522identity.remove%2522">event:"identity.remove"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522identity%2522">event:"identity"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522ignorelist%2522">event:"ignorelist"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522init%2522">event:"init"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522login%2522">event:"login"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522loginfailed%2522">event:"loginfailed"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.addbuffer%2522">event:"network.addbuffer"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.adduser%2522">event:"network.adduser"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.connected%2522">event:"network.connected"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.connectionstate%2522">event:"network.connectionstate"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.disconnected%2522">event:"network.disconnected"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.init%2522">event:"network.init"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.latency%2522">event:"network.latency"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.mynick%2522">event:"network.mynick"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.networkname%2522">event:"network.networkname"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.new%2522">event:"network.new"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.remove%2522">event:"network.remove"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.server%2522">event:"network.server"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.serverlist%2522">event:"network.serverlist"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522network.userrenamed%2522">event:"network.userrenamed"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522setup%2522">event:"setup"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522setupfailed%2522">event:"setupfailed"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522setupok%2522">event:"setupok"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522user.away%2522">event:"user.away"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522user.part%2522">event:"user.part"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522user.quit%2522">event:"user.quit"</a></li><li><a href="module-libquassel-Quassel.html#event:event:%2522user.realname%2522">event:"user.realname"</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">libquassel.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * libquassel
 * https://github.com/magne4000/node-libquassel
 *
 * Copyright (c) 2016 Joël Charles
 * Licensed under the MIT license.
 */

/** @module libquassel */

var net = require('net'),
    zlib = require('zlib'),
    tls = require('tls'),
    RequestType = require('./requesttype'),
    NetworkCollection = require('./network').NetworkCollection,
    Network = require('./network').Network,
    IRCBuffer = require('./buffer').IRCBuffer,
    IRCUser = require('./user'),
    Identity = require('./identity'),
    MessageType = require('./message').Type,
    ignore = require('./ignore'),
    qtdatastream = require('qtdatastream'),
    util = require('util'),
    EventEmitter2 = require('eventemitter2').EventEmitter2,
    logger = require('debug')('libquassel:main'),
    Writer = qtdatastream.Writer;

/**
 * This callback is used by Quassel at login phase
 * @callback module:libquassel~Quassel~loginCallback
 * @param {function} next - callback with 2 parameters: user and password; must be called at the end of this callback
 * @example
 * function(next) {
 *   var user = source.getUser();
 *   var password = source.getPassword();
 *   next(user, password);
 * }
 */

/**
 * Main class to interact with Quassel instance. It extends {@link https://github.com/asyncly/EventEmitter2|EventEmitter2}
 * @class
 * @augments {EventEmitter2}
 * @param {string} server The server hostname or IP address
 * @param {number} port The port on which runs Quassel on the server
 * @param {Object} [options] Allows optionnal parameters
 * @param {boolean} [options.nobacklogs=false] Do not request backlogs (mostly for debug purpose)
 * @param {number} [options.initialbackloglimit=options.backloglimit] number of backlogs to request per buffer at connection
 * @param {number} [options.backloglimit=100] number of backlogs to request per buffer after connection
 * @param {boolean} [options.securecore=true] Use SSL to connect to the core (if the core allows it)
 * @param {module:libquassel~Quassel~loginCallback} loginCallback
 * @example
 * var quassel = new Quassel("localhost", 4242, {}, function(next) {
 *   next("user", "password");
 * });
 * quassel.connect();
 */
var Quassel = function(server, port, options, loginCallback) {
    EventEmitter2.call(this, {wildcard: true});
    var self = this;
    /** @member {?net.Socket} */
    this.client = null;
    /** @member {?qtdatastream.Socket} */
    this.qtsocket = null;
    /** @member {String} */
    this.server = server;
    /** @member {number} */
    this.port = port;
    /** @member {Object} */
    this.options = options || {};
    this.options.backloglimit = parseInt(options.backloglimit || 100, 10);
    this.options.initialbackloglimit = parseInt(options.initialbackloglimit || this.options.backloglimit, 10);
    /** @member {module:network.NetworkCollection} */
    this.networks = new NetworkCollection();
    /** @member {Map.&lt;number, module:identity>} */
    this.identities = new Map;
    /** @member {module:ignore.IgnoreList} */
    this.ignoreList = new ignore.IgnoreList();
    /** @member {number} */
    this.bufferViewId = 0;
    /** @member {?number} */
    this.heartbeatInterval = null;
    /** @member {boolean} */
    this.useSSL = false;
    /** @member {boolean} */
    this.useCompression = false;
    /** @member {?boolean} */
    this.connected = null;
    /** @member {?Object} */
    this.coreInfo = null;
    /** @member {?Object} */
    this.coreData = null;
    
    if (typeof options === 'function' &amp;&amp; typeof loginCallback === 'undefined') {
        /** @member {module:libquassel~Quassel~loginCallback} */
        this.loginCallback = options;
    } else if (typeof loginCallback === 'function') {
        this.loginCallback = loginCallback;
    } else {
        throw new Error("loginCallback parameter is mandatory");
    }
    
    self.init();
};

util.inherits(Quassel, EventEmitter2);

/**
 * This event is fired when quasselcore information are received
 * @event module:libquassel~Quassel#event:"coreinfoinit"
 * @property {Object} data
 * @property {boolean} data.Configured - Is the core configured
 * @property {number} data.CoreFeatures
 * @property {String} data.CoreInfo
 * @property {boolean} data.LoginEnabled
 * @property {boolean} data.MsgType - Is always "ClientInitAck"
 * @property {number} data.ProtocolVersion
 * @property {Array} [data.StorageBackends]
 * @property {boolean} data.SupportSsl
 * @property {boolean} data.SupportsCompression
 */
/**
 * This event is fired upon successful login
 * @event module:libquassel~Quassel#event:"login"
 */
/**
 * This event is fired upon unsuccessful login
 * @event module:libquassel~Quassel#event:"loginfailed"
 */
/**
 * This event is fired upon successful session initialization
 * @event module:libquassel~Quassel#event:"init"
 * @property {Object} obj
 */
/**
 * This event is fired when {@link module:identity} objects are first initialized
 * @event module:libquassel~Quassel#event:"identities.init"
 * @property {Map.&lt;number, module:identity>}
 */
/**
 * This event is fired when a buffer is added to a network
 * @event module:libquassel~Quassel#event:"network.addbuffer"
 * @property {number} networkId
 * @property {number} bufferId
 */
/**
 * Network latency value
 * @event module:libquassel~Quassel#event:"network.latency"
 * @property {number} networkId
 * @property {number} value
 */
/**
 * Network connection state
 * @event module:libquassel~Quassel#event:"network.connectionstate"
 * @property {number} networkId
 * @property {number} connectionState
 */
/**
 * This event is fired when a network state is switched to connected
 * @event module:libquassel~Quassel#event:"network.connected"
 * @property {number} networkId
 */
/**
 * This event is fired when a network state is switched to disconnected
 * @event module:libquassel~Quassel#event:"network.disconnected"
 * @property {number} networkId
 */
/**
 * This event is fired when a user is renamed on a network
 * @event module:libquassel~Quassel#event:"network.userrenamed"
 * @property {number} networkId
 * @property {String} oldNick
 * @property {String} nick
 */
/**
 * This event is fired when current connected user is renamed on a network
 * @event module:libquassel~Quassel#event:"network.mynick"
 * @property {number} networkId
 * @property {String} nick
 */
/**
 * This event is fired when the name of a network changes
 * @event module:libquassel~Quassel#event:"network.networkname"
 * @property {number} networkId
 * @property {String} networkName
 */
/**
 * This event is fired when the server on which a network is connected changes
 * @event module:libquassel~Quassel#event:"network.server"
 * @property {number} networkId
 * @property {String} server
 */
/**
 * This event is fired when a network server list is updated
 * @event module:libquassel~Quassel#event:"network.serverlist"
 * @property {number} networkId
 * @property {Object[]} serverlist
 */
/**
 * Buffer has been marked as read
 * @event module:libquassel~Quassel#event:"buffer.read"
 * @property {number} bufferId
 */
/**
 * Buffer's last seen message updated
 * @event module:libquassel~Quassel#event:"buffer.lastseen"
 * @property {number} bufferId
 * @property {number} messageId
 */
/**
 * Buffer's markeline attached to a message
 * @event module:libquassel~Quassel#event:"buffer.markerline"
 * @property {number} bufferId
 * @property {number} messageId
 */
/**
 * Buffer has been removed
 * @event module:libquassel~Quassel#event:"buffer.remove"
 * @property {number} bufferId
 */
/**
 * Buffer has been renamed
 * @event module:libquassel~Quassel#event:"buffer.rename"
 * @property {number} bufferId
 */
/**
 * bufferId2 has been merged into bufferId1
 * @event module:libquassel~Quassel#event:"buffer.merge"
 * @property {number} bufferId1
 * @property {number} bufferId2
 */
/**
 * Buffer's hidden state removed
 * @event module:libquassel~Quassel#event:"buffer.unhide"
 * @property {number} bufferId
 */
/**
 * Buffer's hidden state set
 * @event module:libquassel~Quassel#event:"buffer.hidden"
 * @property {number} bufferId
 * @property {String} type - Either "temp" or "perm"
 */
/**
 * Buffer set as inactive
 * @event module:libquassel~Quassel#event:"buffer.deactivate"
 * @property {number} bufferId
 */
/**
 * User has left a channel
 * @event module:libquassel~Quassel#event:"user.part"
 * @property {number} networkId
 * @property {String} nick
 * @property {number} bufferId
 */
/**
 * User has left a network
 * @event module:libquassel~Quassel#event:"user.quit"
 * @property {number} networkId
 * @property {String} nick
 */
/**
 * User away state changed
 * @event module:libquassel~Quassel#event:"user.away"
 * @property {number} networkId
 * @property {String} nick
 * @property {boolean} isAway
 */
/**
 * User realname changed
 * @event module:libquassel~Quassel#event:"user.realname"
 * @property {number} networkId
 * @property {String} nick
 * @property {String} realname
 */
/**
 * User joined a channel
 * @event module:libquassel~Quassel#event:"channel.join"
 * @property {number} bufferId
 * @property {String} nick
 */
/**
 * User mode has been added
 * @event module:libquassel~Quassel#event:"channel.addusermode"
 * @property {number} bufferId
 * @property {String} nick
 * @property {String} mode
 */
/**
 * User mode has been removed
 * @event module:libquassel~Quassel#event:"channel.removeusermode"
 * @property {number} bufferId
 * @property {String} nick
 * @property {String} mode
 */
/**
 * Channel topic changed
 * @event module:libquassel~Quassel#event:"channel.topic"
 * @property {number} bufferId
 * @property {String} topic
 */
/**
 * Core information
 * @event module:libquassel~Quassel#event:"coreinfo"
 * @property {Object} data
 */
/**
 * Buffer activated
 * @event module:libquassel~Quassel#event:"buffer.activate"
 * @property {number} bufferId
 */
/**
 * Backlogs received
 * @event module:libquassel~Quassel#event:"buffer.backlog"
 * @property {number} bufferId
 * @property {number[]} messageIds
 */
/**
 * Message received on a buffer
 * @event module:libquassel~Quassel#event:"buffer.message"
 * @property {number} bufferId
 * @property {number} messageId
 */
/**
 * Buffer order changed
 * @event module:libquassel~Quassel#event:"buffer.order"
 * @property {number} bufferId
 * @property {number} indice
 */
/**
 * {@link module:ignore.IgnoreList} updated
 * @event module:libquassel~Quassel#event:"ignorelist"
 */
/**
 * {@link module:identity} updated
 * @event module:libquassel~Quassel#event:"identity"
 */
/**
 * New {@link module:identity} created
 * @event module:libquassel~Quassel#event:"identity.new"
 * @property {number} identityId
 */
/**
 * {@link module:identity} removed
 * @event module:libquassel~Quassel#event:"identity.remove"
 * @property {number} identityId
 */
/**
 * User connected to the {@link module:network.Network}
 * @event module:libquassel~Quassel#event:"network.adduser"
 * @property {number} networkId
 * @property {String} nick
 */
/**
 * New {@link module:network.Network} created
 * @event module:libquassel~Quassel#event:"network.new"
 * @property {number} networkId
 */
/**
 * {@link module:network.Network} removed
 * @event module:libquassel~Quassel#event:"network.remove"
 * @property {number} networkId
 */
/**
 * {@link module:network.Network} is ready
 * @event module:libquassel~Quassel#event:"network.init"
 * @property {number} networkId
 */
/**
 * This event is fired when the core needs it's first setup
 * @event module:libquassel~Quassel#event:"setup"
 * @property {Object[]} backends - List of available storage backends
 * @property {String} backends[].DisplayName - Storage backends name
 * @property {String} backends[].Description - Storage backends description
 * @property {String[]} backends[].SetupKeys - Keys that will need a corresponding value to configure chosen storage backend
 * @property {Object} backends[].SetupDefaults - Defaults values for corresponding SetupKeys
 */
/**
 * This event is fired if the setup of the core was successful
 * @event module:libquassel~Quassel#event:"setupok"
 */
/**
 * This event is fired if the setup of the core has failed
 * @event module:libquassel~Quassel#event:"setupfailed"
 * @property {Object} error - The reason of the failure
 */
/**
 * An error occured
 * @event module:libquassel~Quassel#event:"error"
 * @property {Object} error
 */

/**
 * Handles quasselcore messages that possesses a `MsgType` attribute
 * @param {Object} obj
 * @fires module:libquassel~Quassel#event:"coreinfoinit"
 * @fires module:libquassel~Quassel#event:"login"
 * @fires module:libquassel~Quassel#event:"loginfailed"
 * @fires module:libquassel~Quassel#event:"network.addbuffer"
 * @fires module:libquassel~Quassel#event:"init"
 * @fires module:libquassel~Quassel#event:"setup"
 * @fires module:libquassel~Quassel#event:"setupok"
 * @fires module:libquassel~Quassel#event:"setupfailed"
 * @fires module:libquassel~Quassel#event:"identities.init"
 * @protected
 */
Quassel.prototype.handleMsgType = function(obj) {
    var self = this;
    switch (obj.MsgType) {
        case 'ClientInitAck':
            self.coreInfo = obj;
            self.emit('coreinfoinit', obj);
            if (!obj.Configured) {
                self.emit('setup', obj.StorageBackends);
            } else if (obj.LoginEnabled) {
                self.login();
            } else {
                self.emit('error', new Error("Your core is not supported"));
            }
            break;
        case 'ClientLoginAck':
            self.log('Logged in');
            self.emit('login');
            break;
        case 'ClientLoginReject':
            self.log(obj);
            self.emit('loginfailed');
            break;
        case 'CoreSetupAck':
            self.log('Core setup successful');
            self.emit('setupok');
            break;
        case 'CoreSetupReject':
            self.log('Core setup failed');
            self.emit('setupfailed', obj.Error);
            break;
        case 'SessionInit':
            var i;
            // Init networks
            for (i=0; i&lt;obj.SessionState.NetworkIds.length; i++) {
                // Save network list
                self.networks.add(parseInt(obj.SessionState.NetworkIds[i], 10));
                // Ask server to give more information on each network
                self.sendInitRequest("Network", ""+obj.SessionState.NetworkIds[i]);
            }
            // Attach buffers to network
            for (i=0; i&lt;obj.SessionState.BufferInfos.length; i++) {
                var ircbuffer = new IRCBuffer(obj.SessionState.BufferInfos[i].id, obj.SessionState.BufferInfos[i]);
                if (obj.SessionState.BufferInfos[i].type === IRCBuffer.Types.StatusBuffer) {
                    // Status Buffer special case
                    ircbuffer.isStatusBuffer(true);
                    self.networks.get(ircbuffer.network).setStatusBuffer(ircbuffer);
                }
                self.networks.get(ircbuffer.network).getBufferCollection().addBuffer(ircbuffer);
                if (ircbuffer.isChannel()) {
                    self.sendInitRequest("IrcChannel", ircbuffer.network + "/" + ircbuffer.name);
                }
                self.emit("network.addbuffer", ircbuffer.network, obj.SessionState.BufferInfos[i].id);
            }
            // Init Identities
            for (i=0; i&lt;obj.SessionState.Identities.length; i++) {
                self.identities.set(parseInt(obj.SessionState.Identities[i].identityId, 10), new Identity(obj.SessionState.Identities[i]));
            }
            self.emit('init', obj);
            self.emit('identities.init', self.identities);
            self.sendInitRequest("BufferSyncer", "");
            self.sendInitRequest("BufferViewManager", "");
            self.sendInitRequest("IgnoreListManager", "");
            if (!self.options.nobacklogs &amp;&amp; this.options.initialbackloglimit > 0) {
                setTimeout(function(){
                    self.requestBacklogs(self.options.initialbackloglimit);
                }, 1000);
            }
            self.heartbeatInterval = setInterval(function() {
                self.heartBeat();
            }, 30000);
            break;
        default:
            self.log('Unhandled MsgType ' + obj.MsgType);
    }
};

/**
 * Handles heartbeat
 * @param {boolean} reply - is this a heartbeat reply
 * @protected
 */
Quassel.prototype.heartBeat = function(reply) {
    var d = new Date();
    var secs = d.getSeconds() + (60 * d.getMinutes()) + (60 * 60 * d.getHours());
    var slist = [
        reply?RequestType.HeartBeat:RequestType.HeartBeatReply,
        new qtdatastream.QTime(secs)
    ];
    this.log('Sending heartbeat');
    this.qtsocket.write(slist);
};

/**
 * Get the highest bufferId among all buffers
 * @returns {number}
 */
Quassel.prototype.getMaxBufferId = function() {
    var maxId = 0;
    this.getNetworksMap().forEach(function(network){
        network.getBufferMap().forEach(function(buffer, bufferId){
            if (bufferId > maxId) maxId = bufferId;
        });
    });
    return maxId;
};

// TODO set bufferId to -1
/**
 * Create a {@link module:buffer.IRCBuffer} Object with given name on specified network
 * @param {number} networkId
 * @param {String} name
 * @param {number} [bufferId]
 * @fires module:libquassel~Quassel#event:"network.addbuffer"
 * @returns {number}
 */
Quassel.prototype.createBuffer = function(networkId, name, bufferId) {
    var buffer;
    bufferId = bufferId || this.getMaxBufferId()+1;
    networkId = parseInt(networkId, 10);
    if (name === null) {
        // Assuming that only StatusBuffer have null name
        buffer = new IRCBuffer(bufferId, {type : IRCBuffer.Types.StatusBuffer, network: networkId});
    } else {
        buffer = new IRCBuffer(bufferId, {name: name, network: networkId, type: IRCBuffer.Types.ChannelBuffer});
    }
    this.networks.get(networkId).getBufferCollection().addBuffer(buffer);
    this.emit("network.addbuffer", networkId, bufferId);
};

/**
 * Handles most of the quasselcore messages
 * @param {Object} obj - quasselcore message decoded by qtdatasteam
 * @fires module:libquassel~Quassel#event:"coreinfo"
 * @fires module:libquassel~Quassel#event:"network.init"
 * @fires module:libquassel~Quassel#event:"network.latency"
 * @fires module:libquassel~Quassel#event:"network.connectionstate"
 * @fires module:libquassel~Quassel#event:"network.addbuffer"
 * @fires module:libquassel~Quassel#event:"network.connected"
 * @fires module:libquassel~Quassel#event:"network.disconnected"
 * @fires module:libquassel~Quassel#event:"network.userrenamed"
 * @fires module:libquassel~Quassel#event:"network.mynick"
 * @fires module:libquassel~Quassel#event:"network.networkname"
 * @fires module:libquassel~Quassel#event:"network.server"
 * @fires module:libquassel~Quassel#event:"network.serverlist"
 * @fires module:libquassel~Quassel#event:"network.adduser"
 * @fires module:libquassel~Quassel#event:"network.new"
 * @fires module:libquassel~Quassel#event:"network.remove"
 * @fires module:libquassel~Quassel#event:"buffer.read"
 * @fires module:libquassel~Quassel#event:"buffer.lastseen"
 * @fires module:libquassel~Quassel#event:"buffer.markerline"
 * @fires module:libquassel~Quassel#event:"buffer.remove"
 * @fires module:libquassel~Quassel#event:"buffer.rename"
 * @fires module:libquassel~Quassel#event:"buffer.merge"
 * @fires module:libquassel~Quassel#event:"buffer.unhide"
 * @fires module:libquassel~Quassel#event:"buffer.hidden"
 * @fires module:libquassel~Quassel#event:"buffer.deactivate"
 * @fires module:libquassel~Quassel#event:"buffer.activate"
 * @fires module:libquassel~Quassel#event:"buffer.backlog"
 * @fires module:libquassel~Quassel#event:"buffer.message"
 * @fires module:libquassel~Quassel#event:"buffer.order"
 * @fires module:libquassel~Quassel#event:"user.part"
 * @fires module:libquassel~Quassel#event:"user.quit"
 * @fires module:libquassel~Quassel#event:"user.away"
 * @fires module:libquassel~Quassel#event:"user.realname"
 * @fires module:libquassel~Quassel#event:"channel.join"
 * @fires module:libquassel~Quassel#event:"channel.addusermode"
 * @fires module:libquassel~Quassel#event:"channel.removeusermode"
 * @fires module:libquassel~Quassel#event:"channel.topic"
 * @fires module:libquassel~Quassel#event:"ignorelist"
 * @fires module:libquassel~Quassel#event:"identity"
 * @fires module:libquassel~Quassel#event:"identity.new"
 * @fires module:libquassel~Quassel#event:"identity.remove"
 * @protected
 */
Quassel.prototype.handleStruct = function(obj) {
    var self = this, networkId, identity, identityId, className, functionName, bufferId, buffer, bufferName, messageId, tmp, userNetworkId, userName, networkNick, user, mode, data, oldNick, i, ind, bufferCollection;
    switch (obj[0]) {
        case RequestType.Sync:
            className = obj[1].toString();
            functionName = obj[3].toString();
            self.log(className + " received : " + functionName);
            switch(className) {
                case "Network":
                    networkId = obj[2].toString();
                    switch(functionName) {
                        case "setLatency":
                            self.networks.get(networkId).setLatency(obj[4]);
                            self.emit('network.latency', networkId, obj[4]);
                            break;
                        case "addIrcUser":
                            user = new IRCUser(obj[4]);
                            self.networks.get(networkId).addUser(user);
                            self.sendInitRequest("IrcUser", networkId + "/" + obj[4].split("!")[0]);
                            break;
                        case "setConnectionState":
                            var connectionState = obj[4];
                            var network = self.networks.get(networkId);
                            network.connectionState = connectionState;
                            //If network has no status buffer it is the first time we are connecting to it
                            if (connectionState == Network.ConnectionState.Connecting &amp;&amp; network.getStatusBuffer() === null) {
                                // So we create the corresponding object
                                self.createBuffer(networkId, null);
                            }
                            self.emit('network.connectionstate', networkId, connectionState);
                            break;
                        case "addIrcChannel":
                            bufferName = obj[4];
                            var hasBuffer = self.networks.get(networkId).getBufferCollection().hasBuffer(bufferName);
                            if (hasBuffer) {
                                self.emit('network.addbuffer', networkId, self.networks.get(networkId).getBufferCollection().getBuffer(bufferName).id);
                            }
                            self.sendInitRequest("IrcChannel", networkId + "/" + bufferName);
                            break;
                        case "setConnected":
                            var isConnected = obj[4];
                            self.networks.get(networkId).setConnected(isConnected);
                            if (isConnected) {
                                self.emit('network.connected', networkId);
                            } else {
                                self.emit('network.disconnected', networkId);
                            }
                            break;
                        case "setMyNick":
                            var nick = obj[4];
                            oldNick = self.networks.get(networkId).nick;
                            self.networks.get(networkId).setMyNick(nick);
                            self.networks.get(networkId).renameUser(oldNick, nick);
                            self.emit("network.userrenamed", networkId, oldNick, nick);
                            self.emit('network.mynick', networkId, nick);
                            break;
                        case "setNetworkName":
                            var networkName = obj[4];
                            self.networks.get(networkId).networkName = networkName;
                            self.emit('network.networkname', networkId, networkName);
                            break;
                        case "setCurrentServer":
                            var server = obj[4];
                            self.networks.get(networkId).server = server;
                            self.emit('network.server', networkId, server);
                            break;
                        case "setServerList":
                            var serverList = obj[4];
                            self.networks.get(networkId).ServerList = serverList;
                            self.emit('network.serverlist', networkId, serverList);
                            break;
                        default:
                            self.log('Unhandled Sync.Network ' + functionName);
                    }
                    break;
                case "BufferSyncer":
                    switch(functionName) {
                        case "markBufferAsRead":
                            bufferId = obj[4];
                            self.emit('buffer.read', bufferId);
                            break;
                        case "setLastSeenMsg":
                            bufferId = obj[4];
                            messageId = obj[5];
                            self.emit('buffer.lastseen', bufferId, messageId);
                            break;
                        case "setMarkerLine":
                            bufferId = obj[4];
                            messageId = obj[5];
                            self.emit('buffer.markerline', bufferId, messageId);
                            break;
                        case "removeBuffer":
                            bufferId = obj[4];
                            self.networks.removeBuffer(bufferId);
                            self.emit('buffer.remove', bufferId);
                            break;
                        case "renameBuffer":
                            bufferId = obj[4];
                            var newName = obj[5];
                            self.networks.findBuffer(bufferId).setName(newName);
                            self.emit('buffer.rename', bufferId, newName);
                            break;
                        case 'mergeBuffersPermanently':
                            var bufferId1 = obj[4];
                            var bufferId2 = obj[5];
                            var buffer1 = self.networks.findBuffer(bufferId1);
                            var buffer2 = self.networks.findBuffer(bufferId2);
                            if (buffer1 !== null &amp;&amp; buffer2 !== null) {
                                buffer2.messages.forEach(function(message, messageId){
                                    buffer1.messages.set(messageId, message);
                                });
                            }
                            self.networks.removeBuffer(bufferId2);
                            self.emit('buffer.merge', bufferId1, bufferId2);
                            break;
                        default:
                            self.log('Unhandled Sync.BufferSyncer ' + functionName);
                    }
                    break;
                case "BufferViewConfig":
                    switch(functionName) {
                        case "addBuffer":
                            bufferId = obj[4];
                            buffer = self.networks.findBuffer(bufferId);
                            if (buffer === null){
                                break;
                            }
                            buffer.setTemporarilyRemoved(false);
                            buffer.setPermanentlyRemoved(false);
                            self.networks.get(buffer.network).getBufferCollection()._computeFilteredBuffers();
                            self.emit('buffer.unhide', bufferId);
                            break;
                        case "removeBuffer":
                            bufferId = obj[4];
                            buffer = self.networks.findBuffer(bufferId);
                            if (buffer === null){
                                self.log("Buffer #" + bufferId + " does not exists");
                                break;
                            }
                            buffer.setTemporarilyRemoved(true);
                            self.networks.get(buffer.network).getBufferCollection()._computeFilteredBuffers();
                            self.emit('buffer.hidden', bufferId, "temp");
                            break;
                        case "removeBufferPermanently":
                            bufferId = obj[4];
                            buffer = self.networks.findBuffer(bufferId);
                            if (buffer === null){
                                self.log("Buffer #" + bufferId + " does not exists");
                                break;
                            }
                            buffer.setPermanentlyRemoved(true);
                            self.networks.get(buffer.network).getBufferCollection()._computeFilteredBuffers();
                            self.emit('buffer.hidden', bufferId, "perm");
                            break;
                        default:
                            self.log('Unhandled Sync.BufferViewConfig ' + functionName);
                    }
                    break;
                case "IrcUser":
                    switch(functionName) {
                        case "partChannel":
                            tmp = splitOnce(obj[2], "/");
                            userNetworkId = parseInt(tmp[0], 10);
                            userName = tmp[1];
                            bufferName = obj[4];
                            networkNick = self.networks.get(userNetworkId).nick;
                            buffer = self.networks.get(userNetworkId).getBufferCollection().getBuffer(bufferName);
                            self.networks.get(userNetworkId).getBufferCollection().getBuffer(bufferName).removeUser(userName);
                            self.emit('user.part', userNetworkId, userName, buffer.id);
                            if (buffer.isChannel()) {
                                if (networkNick !== null &amp;&amp; networkNick.toLowerCase() === userName.toLowerCase()) {
                                    // We part
                                    buffer.setActive(false);
                                    self.emit('buffer.deactivate', buffer.id);
                                }
                            } else if (buffer.name === userName){
                                buffer.setActive(false);
                                self.emit('buffer.deactivate', buffer.id);
                            }
                            break;
                        case "quit":
                            tmp = splitOnce(obj[2], "/");
                            userNetworkId = parseInt(tmp[0], 10);
                            userName = tmp[1];
                            networkNick = self.networks.get(userNetworkId).nick;
                            self.networks.get(userNetworkId).removeUser(userName, function(buffer){
                                if (buffer.isChannel()) {
                                    if (networkNick !== null &amp;&amp; networkNick.toLowerCase() === userName.toLowerCase()) {
                                        // We part
                                        buffer.setActive(false);
                                        self.emit('buffer.deactivate', buffer.id);
                                    }
                                } else if (buffer.name === userName) {
                                    buffer.setActive(false);
                                    self.emit('buffer.deactivate', buffer.id);
                                }
                            });
                            self.emit('user.quit', userNetworkId, userName);
                            break;
                        case "setNick":
                            // Already handled by RPC call
                            break;
                        /*case "setServer":
                            // TODO
                            break;*/
                        case "setAway":
                            tmp = splitOnce(obj[2], "/");
                            userNetworkId = parseInt(tmp[0], 10);
                            userName = tmp[1];
                            var isAway = obj[4];
                            user = self.networks.get(userNetworkId).getUserByNick(userName);
                            if (user !== null) {
                                user.away = isAway;
                                self.emit('user.away', userNetworkId, userName, isAway);
                            }
                            break;
                        case "setRealName":
                            tmp = splitOnce(obj[2], "/");
                            userNetworkId = parseInt(tmp[0], 10);
                            userName = tmp[1];
                            var realname = obj[4];
                            user = self.networks.get(userNetworkId).getUserByNick(userName);
                            if (user !== null) {
                                user.realname = realname;
                                self.emit('user.realname', userNetworkId, userName, realname);
                            }
                            break;
                        default:
                            self.log('Unhandled Sync.IrcUser ' + functionName);
                    }
                    break;
                case "IrcChannel":
                    var tmp2 = splitOnce(obj[2], "/");
                    var bufferNetworkId = parseInt(tmp2[0], 10);
                    bufferName = tmp2[1];
                    var attemps = 10;
                    buffer = null;

                    var bufferattempt = function bufferattempt(callback){
                        buffer = self.networks.get(bufferNetworkId).getBufferCollection().getBuffer(bufferName);
                        if (buffer === null &amp;&amp; attemps >= 0) {
                            attemps--;
                            setTimeout(function() {
                                bufferattempt(callback);
                            }, 5);
                        } else if (buffer !== null) {
                            callback(buffer);
                        } else {
                            self.log('Did not succeed to get channel ' + tmp2 + ' after 10 attempts');
                        }
                    };

                    bufferattempt(function(buffer){
                        switch(functionName) {
                            case "joinIrcUsers":
                                for (i=0; i&lt;obj[4].length; i++) {
                                    var user2 = self.networks.get(bufferNetworkId).getUserByNick(obj[4][i]);
                                    buffer.addUser(user2, obj[5][i]);
                                    self.emit('channel.join', buffer.id, obj[4][i]);
                                }
                                break;
                            case "addUserMode":
                                nick = obj[4];
                                mode = obj[5];
                                user = self.networks.get(bufferNetworkId).getUserByNick(nick);
                                buffer.addUserMode(user, mode);
                                self.emit('channel.addusermode', buffer.id, nick, mode);
                                break;
                            case "removeUserMode":
                                nick = obj[4];
                                mode = obj[5];
                                user = self.networks.get(bufferNetworkId).getUserByNick(nick);
                                buffer.removeUserMode(user, mode);
                                self.emit('channel.removeusermode', buffer.id, nick, mode);
                                break;
                            case "setTopic":
                                var topic = obj[4];
                                buffer.topic = topic;
                                self.emit('channel.topic', buffer.id, topic);
                                break;
                            default:
                                self.log('Unhandled Sync.IrcChannel ' + functionName);
                        }
                    });
                    break;
                case "BacklogManager":
                    switch(functionName) {
                        case "receiveBacklog":
                            bufferId = obj[4];
                            data = obj[9];
                            buffer = self.networks.findBuffer(bufferId);
                            if (buffer !== null) {
                                var messageIds = [], message;
                                for (i=0; i&lt;data.length; i++) {
                                    message = buffer.addMessage(data[i]);
                                    if (!message) {
                                        self.log("Getting message buffer already have " + data[i].bufferInfo.name);
                                    } else {
                                        messageIds.push(message.id);
                                        message._updateFlags(self.networks.get(buffer.network).nick);
                                    }
                                }
                                self.emit("buffer.backlog", bufferId, messageIds);
                            } else {
                                self.log("Buffer " + bufferId + " does not exists.");
                            }
                            break;
                        default:
                            self.log('Unhandled Sync.BacklogManager ' + functionName);
                    }
                    break;
                case "IgnoreListManager":
                    switch(functionName) {
                        case "update":
                            data = obj[4];
                            self.ignoreList.import(data);
                            self.emit('ignorelist', self.ignoreList);
                            break;
                        default:
                            self.log('Unhandled Sync.IgnoreListManager ' + functionName);
                    }
                    break;
                case "Identity":
                    identityId = parseInt(obj[2], 10);
                    identity = self.identities.get(identityId);
                    if (identity) {
                        if (typeof identity[functionName] === 'function') {
                            identity[functionName](obj[4]);
                            self.emit('identity.' + functionName, identityId, obj[4]);
                        } else {
                            self.log('Unhandled Sync.Identity ' + functionName);
                        }
                    } else {
                        self.log('Unknown Identity ' + obj[2]);
                    }
                    break;
                default:
                    self.log('Unhandled Sync ' + className);
            }
            break;
        case RequestType.RpcCall:
            functionName = obj[1].toString();
            switch(functionName) {
                case "2displayMsg(Message)":
                    message = obj[2];
                    networkId = message.bufferInfo.network;
                    bufferId = message.bufferInfo.id;
                    bufferCollection = self.networks.get(networkId).getBufferCollection();
                    if (!bufferCollection.hasBuffer(bufferId)) {
                        if (bufferCollection.hasBuffer(message.bufferInfo.name)) {
                            buffer = bufferCollection.getBuffer(message.bufferInfo.name);
                            bufferCollection.moveBuffer(buffer, bufferId);
                        } else {
                            buffer = new IRCBuffer(bufferId, message.bufferInfo);
                            bufferCollection.addBuffer(buffer);
                        }
                        self.emit("network.addbuffer", networkId, bufferId);
                    }
                    
                    if (message.type === MessageType.NetsplitJoin) {
                        // TODO
                    } else if (message.type === MessageType.NetsplitQuit) {
                        // TODO
                    }

                    buffer = bufferCollection.getBuffer(bufferId);
                    if (buffer !== null) {
                        var simpleMessage = buffer.addMessage(message);
                        if (simpleMessage) {
                            simpleMessage._updateFlags(self.networks.get(networkId).nick);
                            self.emit("buffer.message", bufferId, simpleMessage.id);
                        }
                    }
                    break;
                case "__objectRenamed__":
                    var renamedSubject = obj[2].toString();
                    switch(renamedSubject) {
                        case "IrcUser":
                            var newNick = splitOnce(obj[3], "/"); // 1/Nick
                            oldNick = splitOnce(obj[4], "/"); // 1/Nick_
                            self.networks.get(newNick[0]).renameUser(oldNick[1], newNick[1]);
                            self.emit("network.userrenamed", newNick[0], oldNick[1], newNick[1]);
                            break;
                        default:
                            self.log('Unhandled RpcCall.__objectRenamed__ ' + renamedSubject);
                    }
                    break;
                case "2networkCreated(NetworkId)":
                    networkId = obj[2];
                    self.networks.add(networkId);
                    self.sendInitRequest("Network", ""+networkId);
                    self.emit("network.new", networkId);
                    break;
                case "2networkRemoved(NetworkId)":
                    networkId = obj[2];
                    self.networks.remove(networkId);
                    self.emit("network.remove", networkId);
                    break;
                case "2identityCreated(Identity)":
                    identity = obj[2];
                    self.identities.set(identity.identityId, new Identity(identity));
                    self.emit("identity.new", identity.identityId);
                    break;
                case "2identityRemoved(IdentityId)":
                    identityId = obj[2];
                    self.identities.delete(identityId);
                    self.emit('identity.remove', identityId);
                    break;
                default:
                    self.log('Unhandled RpcCall ' + functionName);
            }
            break;
        case RequestType.InitData:
            className = obj[1].toString();
            switch(className) {
                case "Network":
                    network = self.handleInitDataNetwork(obj);
                    var syncRequest = [
                        new qtdatastream.QUInt(RequestType.Sync),
                        new qtdatastream.QString("BufferSyncer"),
                        new qtdatastream.QString(""),
                        new qtdatastream.QString("requestPurgeBufferIds")
                    ];
                    self.qtsocket.write(syncRequest);
                    self.emit("network.init", network.networkId);
                    break;
                case "BufferSyncer":
                    var markerLinesData = obj[3]["MarkerLines"];
                    var lastSeenData = obj[3]["LastSeenMsg"];
                    if (lastSeenData !== null) {
                        for (i=0; i&lt;lastSeenData.length; i+=2) {
                            bufferId = lastSeenData[i];
                            messageId = lastSeenData[i+1];
                            buffer = self.networks.findBuffer(bufferId);
                            if (buffer !== null) {
                                self.emit('buffer.lastseen', bufferId, messageId);
                            } else {
                                self.log("Buffer #" + bufferId + " does not exists");
                            }
                        }
                    } else {
                        self.log("Received null LastSeenMsg");
                    }
                    if (markerLinesData !== null) {
                        for (i=0; i&lt;markerLinesData.length; i+=2) {
                            bufferId = markerLinesData[i];
                            messageId = markerLinesData[i+1];
                            buffer = self.networks.findBuffer(bufferId);
                            if (buffer !== null) {
                                self.emit('buffer.markerline', bufferId, messageId);
                            } else {
                                self.log("Buffer #" + bufferId + " does not exists");
                            }
                        }
                    } else {
                        self.log("Received null markerLines");
                    }
                    break;
                case "IrcUser":
                    tmp = splitOnce(obj[2], "/");
                    data = obj[3];
                    networkId = parseInt(tmp[0], 10);
                    user = self.networks.get(networkId).getUserByNick(tmp[1]);
                    if (user !== null) {
                        user.devour(data);
                        self.emit('network.adduser', networkId, tmp[1]);
                    }
                    break;
                case "IrcChannel":
                    tmp = splitOnce(obj[2], "/");
                    data = obj[3];
                    bufferNetworkId = parseInt(tmp[0], 10);
                    bufferName = tmp[1];
                    buffer = self.networks.get(bufferNetworkId).getBufferCollection().getBuffer(bufferName);
                    buffer.topic = data.topic;
                    buffer.active = true;
                    self.emit('channel.topic', bufferNetworkId, bufferName, data.topic);
                    self.emit('buffer.activate', buffer.id);
                    break;
                case "BufferViewManager":
                    data = obj[3]["BufferViewIds"];
                    if (data.length > 0) {
                        self.sendInitRequest("BufferViewConfig", ""+data[0]);
                    }
                    self.bufferViewId = data[0];
                    break;
                case "BufferViewConfig":
                    data = obj[3];
                    for (ind in data.TemporarilyRemovedBuffers) {
                        buffer = self.networks.findBuffer(data.TemporarilyRemovedBuffers[ind]);
                        if (buffer !== null) {
                            buffer.setTemporarilyRemoved(true);
                            self.emit('buffer.hidden', buffer.id, "temp");
                        }
                    }
                    for (ind in data.RemovedBuffers) {
                        buffer = self.networks.findBuffer(data.RemovedBuffers[ind]);
                        if (buffer !== null) {
                            buffer.setPermanentlyRemoved(true);
                            self.emit('buffer.hidden', buffer.id, "perm");
                        }
                    }
                    for (ind in data.BufferList) {
                        buffer = self.networks.findBuffer(data.BufferList[ind]);
                        if (buffer !== null) {
                            buffer.setOrder(ind);
                            self.emit('buffer.order', buffer.id, ind);
                        }
                    }
                    break;
                case "IgnoreListManager":
                    data = obj[3];
                    self.ignoreList.import(data);
                    self.emit('ignorelist', self.ignoreList);
                    break;
                case "CoreInfo":
                    data = obj[3];
                    self.coreData = data;
                    self.emit('coreinfo', data);
                    break;
                default:
                    self.log('Unhandled InitData ' + className);
            }
            break;
        case RequestType.HeartBeat:
            self.log('HeartBeat');
            self.heartBeat(true);
            break;
        case RequestType.HeartBeatReply:
            self.log('HeartBeatReply');
            break;
        default:
            self.log('Unhandled RequestType ' + obj[0]);
    }
};

/**
 * Dispatch quasselcore messages
 * @param {Object} obj
 * @protected
 */
Quassel.prototype.dispatch = function(obj) {
    if (obj === null) {
        this.log("Received null object ... ?");
    } else if (typeof obj.MsgType !== 'undefined') {
        this.handleMsgType(obj);
    } else if(Buffer.isBuffer(obj[1])) {
        this.handleStruct(obj);
    }
};

/**
 * Affects obj to corresponding {@link module:network.Network}
 * @param {Object} obj
 * @protected
 */
Quassel.prototype.handleInitDataNetwork = function(obj) {
    var networkId = parseInt(obj[2], 10);
    var network = this.networks.get(networkId);
    network.devour(obj[3]);
    return network;
};

/**
 * Sends a request to quasselcore to fetch initial backlogs for all buffers
 * @param {number} limit
 */
Quassel.prototype.requestBacklogs = function(limit){
    var self = this;
    this.networks.hm.forEach(function(network){
        var buffers = network.getBufferMap();
        buffers.forEach(function(value) {
            self.requestBacklog(value.id, -1, -1, limit);
        });
    });
};

/**
 * Sends an initialization request to quasselcore for specified `classname` and `objectname`
 * @param {String} classname
 * @param {String} objectname
 * @example
 * self.sendInitRequest("IrcUser", "1/randomuser");
 */
Quassel.prototype.sendInitRequest = function(classname, objectname) {
    var initRequest = [
        new qtdatastream.QUInt(RequestType.InitRequest),
        new qtdatastream.QString(classname),
        new qtdatastream.QString(objectname)
    ];
    this.qtsocket.write(initRequest);
};

/**
 * Sends client information to quasselcore
 * @param {boolean} useSSL
 * @param {boolean} useCompression - Not supported
 * @protected
 */
Quassel.prototype.sendClientInfo = function(useSSL, useCompression){
    var smap = {
        "ClientDate": "Apr 14 2014 17:18:30",
        "UseSsl": useSSL,
        "ClientVersion": "JS libquassel v1.0",
        "UseCompression": useCompression,
        "MsgType": "ClientInit",
        "ProtocolVersion": 10
    };
    this.log('Sending client informations');
    this.qtsocket.write(smap);
};

/**
 * Initialize connection settings
 * @fires module:libquassel~Quassel#event:"error"
 * @protected
 */
Quassel.prototype.init = function() {
    var self = this;
    this.client = net.Socket();
    
    // Handle magic number response
    this.client.once('data', function(data) {
        var ret = data.readUInt32BE(0);
        if (((ret >> 24) &amp; 0x01) > 0) {
            self.useSSL = true;
            self.log('Using SSL');
        }
        
        if (((ret >> 24) &amp; 0x02) > 0) {
            self.useCompression = true;
            self.log('Using compression');
        }
        
        
        if (self.useCompression) {
            // Not working, don't know why yet
            self.qtsocket = new qtdatastream.Socket(self.client, function(buffer, next) {
                zlib.inflate(buffer, next);
            }, function(buffer, next) {
                var deflate = zlib.createDeflate({flush: zlib.Z_SYNC_FLUSH}), buffers = [];
                deflate.on('data', function(chunk) {
                    buffers.push(chunk);
                });
                
                deflate.on('end', function() {
                    self.log(buffers);
                    next(null, Buffer.concat(buffers));
                });
                
                deflate.end(buffer);
            });
        } else {
            self.qtsocket = new qtdatastream.Socket(self.client);
        }
        
        // bind events on qtsocket
        self.qtsocket.on('data', function(data) {
            self.dispatch(data);
        })
        .on('close', function() {
            self.log('Connection closed');
        })
        .on('end', function() {
            self.log('END');
        })
        .on('error', function(e) {
            console.log('ERROR', e);
            self.emit('error', e);
        });
        
        self.sendClientInfo(self.useSSL, self.useCompression);
    });
    
    this.client.on('error', function(e) {
        console.log('ERROR', e);
        self.emit('error', e);
    });  
};

/**
 * Get network collection
 * @returns {module:network.NetworkCollection}
 */
Quassel.prototype.getNetworks = function() {
    return this.networks;
};

/**
 * Get network Map
 * @returns {Map.&lt;number, module:network.Network>}
 */
Quassel.prototype.getNetworksMap = function() {
    return this.networks.hm;
};

/**
 * Setup core
 * @param {String} backend
 * @param {String} adminuser
 * @param {String} adminpassword
 * @param {Object} [properties]
 */
Quassel.prototype.setupCore = function(backend, adminuser, adminpassword, properties) {
    properties = properties || {};
    var obj = {
        SetupData: {
            ConnectionProperties: properties,
            Backend: backend,
            AdminUser: adminuser,
            AdminPasswd: adminpassword
        },
        MsgType: 'CoreSetupData'
    };
    this.qtsocket.write(obj);
};

/**
 * Login to quasselcore
 */
Quassel.prototype.login = function() {
    var self = this;
    if (self.useSSL) {
        var secureStream = tls.connect(null, {
            socket: self.qtsocket.socket,
            rejectUnauthorized: false,
            secureProtocol: 'TLSv1_client_method'
        });
        self.qtsocket.updateSocket(secureStream);
    }

    self.loginCallback(function(user, password) {
        var obj = {
            "MsgType": "ClientLogin",
            "User": user,
            "Password": password
        };
        self.qtsocket.write(obj);
    });
};

/**
 * Initialize the connection
 * @example
 * var quassel = new Quassel(...);
 * quassel.connect();
 */
Quassel.prototype.connect = function() {
    var self = this;
    var magic = 0x42b33f00;
    // magic | 0x01 Encryption
    // magic | 0x02 Compression
    if (self.options.securecore) {
        magic = magic | 0x01;
    }
    
    if (this.connected !== null) {
        this.init();
    }
    
    this.client.connect(this.port, this.server, function(){
        var writer = new Writer();
        writer.writeUInt(magic);
        writer.writeUInt(0x01);
        writer.writeUInt(0x01 &lt;&lt; 31);
        self.client.write(writer.getRawBuffer());
        self.connected = true;
    });
};

/**
 * Disconnect the client from the core
 */
Quassel.prototype.disconnect = function() {
    clearInterval(this.heartbeatInterval);
    this.client.end();
    this.client.destroy();
    this.connected = false;
};

/**
 * Core RPC request - Create a new {@link module:identity}
 * @param {String} identityName
 * @param {Object} [options]
 * @param {String} [options.realName=identityName]
 * @param {String} [options.nick=identityName]
 * @param {String} [options.awayNick=""]
 * @param {boolean} [options.awayNickEnabled=false]
 * @param {String} [options.awayReason="Gone fishing."]
 * @param {boolean} [options.awayReasonEnabled=true]
 * @param {boolean} [options.autoAwayEnabled=false]
 * @param {number} [options.autoAwayTime=10]
 * @param {String} [options.autoAwayReason="Not here. No, really. not here!"]
 * @param {boolean} [options.autoAwayReasonEnabled=false]
 * @param {boolean} [options.detachAwayEnabled=false]
 * @param {String} [options.detachAwayReason="All Quassel clients vanished from the face of the earth..."]
 * @param {boolean} [options.detachAwayReasonEnabled=false]
 * @param {String} [options.ident="quassel"]
 * @param {String} [options.kickReason="Kindergarten is elsewhere!"]
 * @param {String} [options.partReason="http://quassel-irc.org - Chat comfortably. Anywhere."]
 * @param {String} [options.quitReason="http://quassel-irc.org - Chat comfortably. Anywhere."]
 */
Quassel.prototype.createIdentity = function(identityName, options) {
    options = options || {};
    var slit = [
        new qtdatastream.QInt(RequestType.RpcCall),
        "2createIdentity(Identity,QVariantMap)",
        new qtdatastream.QUserType("Identity", {
            identityId: new qtdatastream.QUserType("IdentityId", -1),
            identityName: identityName,
            realName: options.realName || identityName,
            nicks: [options.nick || identityName],
            awayNick: options.awayNick || "",
            awayNickEnabled: options.awayNickEnabled || false,
            awayReason: options.awayReason || "Gone fishing.",
            awayReasonEnabled: options.awayReasonEnabled || true,
            autoAwayEnabled: options.autoAwayEnabled || false,
            autoAwayTime: options.autoAwayTime || 10,
            autoAwayReason: options.autoAwayReason || "Not here. No, really. not here!",
            autoAwayReasonEnabled: options.autoAwayReasonEnabled || false,
            detachAwayEnabled: options.detachAwayEnabled || false,
            detachAwayReason: options.detachAwayReason || "All Quassel clients vanished from the face of the earth...",
            detachAwayReasonEnabled: options.detachAwayReasonEnabled || false,
            ident: options.ident || "quassel",
            kickReason: options.kickReason || "Kindergarten is elsewhere!",
            partReason: options.partReason || "http://quassel-irc.org - Chat comfortably. Anywhere.",
            quitReason: options.quitReason || "http://quassel-irc.org - Chat comfortably. Anywhere."
        }),
        {}
    ];
    this.log('Creating identity');
    this.qtsocket.write(slit);
};

/**
 * Core RPC request - Remove an {@link module:identity}
 * @param {number} identityId
 */
Quassel.prototype.removeIdentity = function(identityId) {
    var slit = [
        new qtdatastream.QInt(RequestType.RpcCall),
        "2removeIdentity(IdentityId)",
        new qtdatastream.QUserType("IdentityId", identityId)
    ];
    this.log('Deleting identity');
    this.qtsocket.write(slit);
};

function _serverListDefaults(server) {
    return {
        Host: server.host,
        Port: server.port || "6667",
        Password: server.password || "",
        UseSSL: server.useSsl || true,
        sslVersion: server.sslVersion || 0,
        /* Lowercase in the protocol */
        UseProxy: server.useProxy || false,
        ProxyType: server.proxyType || 0,
        ProxyHost: server.proxyHost || "",
        ProxyPort: server.proxyPort || "",
        ProxyUser: server.proxyUser || "",
        ProxyPass: server.proxyPass || ""
    };
}

/**
 * Core RPC request - Create a {@link module:network.Network}
 * @param {String} networkName
 * @param {number} identityId
 * @param {(String|Object)} initialServer - Server hostname or IP, or full Network::Server Object. Can also be undefined if options.ServerList is defined.
 * @param {String} [initialServer.host=initialServer]
 * @param {String} [initialServer.port="6667"]
 * @param {String} [initialServer.password=""]
 * @param {boolean} [initialServer.useSsl=true]
 * @param {number} [initialServer.sslVersion=0]
 * @param {boolean} [initialServer.useProxy=false]
 * @param {number} [initialServer.proxyType=0]
 * @param {String} [initialServer.proxyHost=""]
 * @param {String} [initialServer.proxyPort=""]
 * @param {String} [initialServer.proxyUser=""]
 * @param {String} [initialServer.proxyPass=""]
 * @param {Object} [options]
 * @param {String} [options.codecForServer=""]
 * @param {String} [options.codecForEncoding=""]
 * @param {String} [options.codecForDecoding=""]
 * @param {boolean} [options.useRandomServer=false]
 * @param {String[]} [options.perform=[]]
 * @param {Object[]} [options.ServerList=[]]
 * @param {boolean} [options.useAutoIdentify=false]
 * @param {String} [options.autoIdentifyService="NickServ"]
 * @param {String} [options.autoIdentifyPassword=""]
 * @param {boolean} [options.useSasl=false
 * @param {String} [options.saslAccount=""]
 * @param {String} [options.saslPassword=""]
 * @param {boolean} [options.useAutoReconnect=true]
 * @param {number} [options.autoReconnectInterval=60]
 * @param {number} [options.autoReconnectRetries=20]
 * @param {boolean} [options.unlimitedReconnectRetries=false]
 * @param {boolean} [options.rejoinChannels=true]
 */
Quassel.prototype.createNetwork = function(networkName, identityId, initialServer, options) {
    options = options || {};
    if (typeof initialServer === "string") {
        initialServer = {
            host: initialServer
        };
    }
    var serverList = [];
    if (options.ServerList &amp;&amp; options.ServerList.length > 0) {
        for (var i=0; i&lt;options.ServerList.length; i++) {
            serverList.push(new qtdatastream.QUserType("Network::Server", _serverListDefaults(options.ServerList[i])));
        }
    } else {
        serverList = [new qtdatastream.QUserType("Network::Server", _serverListDefaults(initialServer))];
    }
    var slit = [
        new qtdatastream.QInt(RequestType.RpcCall),
        "2createNetwork(NetworkInfo,QStringList)",
        new qtdatastream.QUserType("NetworkInfo", {
            NetworkId: new qtdatastream.QUserType("NetworkId", -1),
            NetworkName: networkName,
            Identity: new qtdatastream.QUserType("IdentityId", identityId),
            // useCustomEncodings: false,
            CodecForServer: new qtdatastream.QByteArray(options.codecForServer || ""),
            CodecForEncoding: new qtdatastream.QByteArray(options.codecForEncoding || ""),
            CodecForDecoding: new qtdatastream.QByteArray(options.codecForDecoding || ""),
            ServerList: serverList,
            UseRandomServer: options.useRandomServer || false,
            Perform: options.perform || [],
            UseAutoIdentify: options.useAutoIdentify || false,
            AutoIdentifyService: options.autoIdentifyService || "NickServ",
            AutoIdentifyPassword: options.autoIdentifyPassword || "",
            UseSasl: options.useSasl || false,
            SaslAccount: options.saslAccount || "",
            SaslPassword: options.saslPassword || "",
            UseAutoReconnect: options.useAutoReconnect || true,
            AutoReconnectInterval: options.autoReconnectInterval || 60,
            AutoReconnectRetries: options.autoReconnectRetries || 20,
            UnlimitedReconnectRetries: options.unlimitedReconnectRetries || false,
            RejoinChannels: options.rejoinChannels || true
        }),
        new qtdatastream.QStringList([])
    ];
    this.log('Creating network');
    this.qtsocket.write(slit);
};

/**
 * Core RPC request - Remove a {@link module:network.Network}
 * @param {number} networkId
 */
Quassel.prototype.removeNetwork = function(networkId) {
    var slit = [
        new qtdatastream.QInt(RequestType.RpcCall),
        "2removeNetwork(NetworkId)",
        new qtdatastream.QUserType("NetworkId", networkId)
    ];
    this.log('Deleting nhetwork');
    this.qtsocket.write(slit);
};

/**
 * Core RPC request - Send a user input to a specified buffer
 * @param {number} bufferId
 * @param {String} message
 */
Quassel.prototype.sendMessage = function(bufferId, message) {
    var buffer = this.networks.findBuffer(parseInt(bufferId, 10));
    if (buffer !== null) {
        var slit = [
            new qtdatastream.QInt(RequestType.RpcCall),
            "2sendInput(BufferInfo,QString)",
            new qtdatastream.QUserType("BufferInfo", buffer.getBufferInfo()),
            new qtdatastream.QString(message)
        ];
        this.log('Sending message');
        this.qtsocket.write(slit);
    } else {
        this.log("Could not send message to buffer " + bufferId + ". Buffer not found.");
    }
};

/**
 * Core Sync request - Backlogs
 * @param {number} bufferId
 * @param {number} [firstMsgId=-1]
 * @param {number} [lastMsgId=-1]
 * @param {number} [maxAmount=backloglimit]
 */
Quassel.prototype.requestBacklog = function(bufferId, firstMsgId, lastMsgId, maxAmount) {
    firstMsgId = firstMsgId || -1;
    lastMsgId = lastMsgId || -1;
    maxAmount = maxAmount || this.options.backloglimit;
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "BacklogManager",
        "",
        "requestBacklog",
        new qtdatastream.QUserType("BufferId", bufferId),
        new qtdatastream.QUserType("MsgId", firstMsgId),
        new qtdatastream.QUserType("MsgId", lastMsgId),
        new qtdatastream.QInt(maxAmount),
        new qtdatastream.QInt(0)
    ];
    this.log('Sending backlog request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Disconnect the specified network
 * @param {number} networkId
 */
Quassel.prototype.requestDisconnectNetwork = function(networkId) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "Network",
        ""+networkId,
        new qtdatastream.QByteArray("requestDisconnect")
    ];
    this.log('Sending disconnection request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Connect the specified network
 * @param {number} networkId
 */
Quassel.prototype.requestConnectNetwork = function(networkId) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "Network",
        ""+networkId,
        new qtdatastream.QByteArray("requestConnect")
    ];
    this.log('Sending connection request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Mark buffer as read
 * @param {number} bufferId
 */
Quassel.prototype.requestMarkBufferAsRead = function(bufferId) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "BufferSyncer",
        "",
        new qtdatastream.QByteArray("requestMarkBufferAsRead"),
        new qtdatastream.QUserType("BufferId", bufferId)
    ];
    this.log('Sending mark buffer as read request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Set all messages before messageId as read for specified buffer
 * @param {number} bufferId
 * @param {number} messageId
 */
Quassel.prototype.requestSetLastMsgRead = function(bufferId, messageId) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "BufferSyncer",
        "",
        new qtdatastream.QByteArray("requestSetLastSeenMsg"),
        new qtdatastream.QUserType("BufferId", bufferId),
        new qtdatastream.QUserType("MsgId", messageId)
    ];
    this.log('Sending last message read request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Mark a specified buffer line
 * @param {number} bufferId
 * @param {number} messageId
 */
Quassel.prototype.requestSetMarkerLine = function(bufferId, messageId) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "BufferSyncer",
        "",
        new qtdatastream.QByteArray("requestSetMarkerLine"),
        new qtdatastream.QUserType("BufferId", bufferId),
        new qtdatastream.QUserType("MsgId", messageId)
    ];
    this.log('Sending mark line request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Remove a buffer
 * @param {number} bufferId
 */
Quassel.prototype.requestRemoveBuffer = function(bufferId) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "BufferSyncer",
        "",
        new qtdatastream.QByteArray("requestRemoveBuffer"),
        new qtdatastream.QUserType("BufferId", bufferId)
    ];
    this.log('Sending perm hide request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Merge bufferId2 into bufferId1
 * @param {number} bufferId1
 * @param {number} bufferId2
 */
Quassel.prototype.requestMergeBuffersPermanently = function(bufferId1, bufferId2) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "BufferSyncer",
        "",
        new qtdatastream.QByteArray("requestMergeBuffersPermanently"),
        new qtdatastream.QUserType("BufferId", bufferId1),
        new qtdatastream.QUserType("BufferId", bufferId2)
    ];
    this.log('Sending merge request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Hide a buffer temporarily
 * @param {number} bufferId
 */
Quassel.prototype.requestHideBufferTemporarily = function(bufferId) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "BufferViewConfig",
        ""+this.bufferViewId,
        "requestRemoveBuffer",
        new qtdatastream.QUserType("BufferId", bufferId)
    ];
    this.log('Sending temp hide request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Hide a buffer permanently
 * @param {number} bufferId
 */
Quassel.prototype.requestHideBufferPermanently = function(bufferId) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "BufferViewConfig",
        ""+this.bufferViewId,
        "requestRemoveBufferPermanently",
        new qtdatastream.QUserType("BufferId", bufferId)
    ];
    this.log('Sending perm hide request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Unhide a buffer
 * @param {number} bufferId
 */
Quassel.prototype.requestUnhideBuffer = function(bufferId) {
    bufferId = parseInt(bufferId, 10);
    var buffer = this.getNetworks().findBuffer(bufferId);
    var bufferCount = this.getNetworks().get(buffer.network).getBufferMap().count();
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "BufferViewConfig",
        ""+this.bufferViewId,
        "requestAddBuffer",
        new qtdatastream.QUserType("BufferId", bufferId),
        new qtdatastream.QInt(bufferCount)
    ];
    this.log('Sending unhide request');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Update ignoreList
 * @param {object} ignoreList
 */
Quassel.prototype.requestUpdateIgnoreListManager = function(ignoreList) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        "IgnoreListManager",
        "",
        "requestUpdate",
        ignoreList
    ];
    this.log('Sending update request (IgnoreListManager)');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Update identity
 * @param {Number} identityId
 * @param {object} identity
 */
Quassel.prototype.requestUpdateIdentity = function(identityId, identity) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        new qtdatastream.QByteArray("Identity"),
        ""+identityId,
        new qtdatastream.QByteArray("requestUpdate"),
        identity
    ];
    this.log('Sending update request (Identity)');
    this.qtsocket.write(slist);
};

/**
 * Core Sync request - Update network information
 * @param {Number} networkId
 * @param {object} network
 */
Quassel.prototype.requestSetNetworkInfo = function(networkId, network) {
    var slist = [
        new qtdatastream.QInt(RequestType.Sync),
        new qtdatastream.QByteArray("Network"),
        ""+networkId,
        new qtdatastream.QByteArray("requestSetNetworkInfo"),
        Network.toQ(network)
    ];
    this.log('Sending update request (Network)');
    this.qtsocket.write(slist);
};

Quassel.prototype.log = function(m) {
    logger(m);
};

/**
 * Qt UserType
 * @typedef UserType
 * @see https://github.com/magne4000/node-qtdatastream/blob/master/README.md#qusertype-special-treatment
 * @example
 * new qtdatastream.Writer({
 *   "NetworkId": new QUserType("NetworkId", 1)
 * });
 * @example
 * new qtdatastream.Writer({
 *   "BufferInfo": new QUserType("BufferInfo", {
 *     id: 2,
 *     network: 4,
 *     type: 5,
 *     group: 1,
 *     name: "something"
 *   })
 * });
 */

/**
 * @typedef {UserType} UserType&amp;lt;NetworkId&amp;gt;
 * @property {INT} this
 */
qtdatastream.registerUserType("NetworkId", qtdatastream.Types.INT);

/**
 * @typedef {UserType} UserType&amp;lt;IdentityId&amp;gt;
 * @property {INT} this
 */
qtdatastream.registerUserType("IdentityId", qtdatastream.Types.INT);

/**
 * @typedef {UserType} UserType&amp;lt;BufferId&amp;gt;
 * @property {INT} this
 */
qtdatastream.registerUserType("BufferId", qtdatastream.Types.INT);

/**
 * @typedef {UserType} UserType&amp;lt;MsgId&amp;gt;
 * @property {INT} this
 */
qtdatastream.registerUserType("MsgId", qtdatastream.Types.INT);

/**
 * @typedef {UserType} UserType&amp;lt;Identity&amp;gt;
 * @property {MAP} this
 */
qtdatastream.registerUserType("Identity", qtdatastream.Types.MAP);

/**
 * @typedef {UserType} UserType&amp;lt;NetworkInfo&amp;gt;
 * @property {MAP} this
 */
qtdatastream.registerUserType("NetworkInfo", qtdatastream.Types.MAP);

/**
 * @typedef {UserType} UserType&amp;lt;Network::Server&amp;gt;
 * @property {MAP} this
 */
qtdatastream.registerUserType("Network::Server", qtdatastream.Types.MAP);

/**
 * @typedef {UserType} UserType&amp;lt;NetworkId&amp;gt;
 * @property {INT} this
 */
qtdatastream.registerUserType("NetworkId", qtdatastream.Types.INT);

/**
 * @typedef {UserType} UserType&amp;lt;BufferInfo&amp;gt;
 * @property {INT} id
 * @property {INT} network
 * @property {SHORT} type
 * @property {UINT} group
 * @property {BYTEARRAY} name
 */
qtdatastream.registerUserType("BufferInfo", [
    {id: qtdatastream.Types.INT},
    {network: qtdatastream.Types.INT},
    {type: qtdatastream.Types.SHORT},
    {group: qtdatastream.Types.UINT},
    {name: qtdatastream.Types.BYTEARRAY}
]);

/**
 * @typedef {UserType} UserType&amp;lt;Message&amp;gt;
 * @property {INT} id
 * @property {UINT} timestamp
 * @property {UINT} type
 * @property {BOOL} flags
 * @property {UserType&lt;BufferInfo>} bufferInfo
 * @property {BYTEARRAY} sender
 * @property {BYTEARRAY} content
 */
qtdatastream.registerUserType("Message", [
    {id: qtdatastream.Types.INT},
    {timestamp: qtdatastream.Types.UINT},
    {type: qtdatastream.Types.UINT},
    {flags: qtdatastream.Types.BOOL},
    {bufferInfo: "BufferInfo"},
    {sender: qtdatastream.Types.BYTEARRAY},
    {content: qtdatastream.Types.BYTEARRAY}
]);

function splitOnce(str, character) {
    var i = str.indexOf(character);
    return [str.slice(0,i), str.slice(i+1)];
}

module.exports = Quassel;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Apr 18 2016 11:21:00 GMT+0200 (CEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
